# Notes on scene and robot model files

## Import

There is ways to import from URDF or similar XML type
descriptions. There are also some working examples to import
`gltf`. With Bremen we also managed to import a [full
kitchen](https://github.com/MarcToussaint/rai-robotModels/tree/master/bremenKitchen)
from unreal. More info on the rai wiki.

## Continuous editing using `kinEdit`

Compile the binary (with CMake, this is usually compiled in the build/)
```
cd rai  # into the rai submodule
make bin
```
perhaps export
```
echo 'export PATH="$HOME/path-to-rai/bin:$PATH"' >> $HOME/.bashrc
```

Then you can call `kinEdit someFile.g` from anywhere on any model
file. This displays and animates the model. (In python, the equivalence is to reload the configuration from file repeatedly.) While displaying the
model, edit the file in any other editor and save. `kinEdit` then
notices that the file changed and reloads and directly displays your
changes -- or writes parsing errors to the console. You might
sometimes have to hit enter in the window or restart `kinEdit` on such
errors. Some parse errors might not be caught properly and `kinEdit` crashes -- then you need to restart.

Whenever `kinEdit` reads a file, it also outputs a file `z.g` of what
it read. Sometimes it is useful to look into this.

## Editing robot model/configuration files

Example: This is a description of a full humanoid ([hubo.g](https://github.com/MarcToussaint/rai-robotModels/blob/master/hubo/hubo_clean.g))

See [graph.md](graph.md) for a general description of the `.g` file syntax. The .g-syntax is a general graph syntax. For robot configuration files, every node is a frame; a node/frame can have at most 1 parent; and every node needs to have an dictionary that defines (relative) pose, joints, shapes, and/or inertias.

See [rai::Frame](https://github.com/MarcToussaint/rai/blob/master/rai/Kin/frame.h) for the definition of the underlying data structure.

Kinematic configurations are frame trees.

The declaration `stem(table1)` declares a new frame
with name `stem` and parent `table1`. The dictionary `{...}`
defines parameters of this frame and what is associated to the frame.

Internally, every frame has an absolute world pose `X`, and, if it is a child of
a parent, a relative transformation `Q` from parent to this
frame. Forward kinematics means nothing but forward chaining `Q`s to
compute `X`s for all frames.

We can associate to a frame any (or none) of the following:
* A `shape`, which requires either a `mesh` filename given, or a primitive shape type with given `size`
* A `joint`, which means that `Q` is a differentiable function of some DOFs, rather than fixed.
* A `mass`, which means that the frame can act as a dynamic body in a physical simulation

Let's read in detail
```
stick (table1){
  shape:ST_ssBox size:[.8 .025 .04 .01] color:[.6 .3 0] contact, logical:{ object }
  Q:<t(0 0 .1) t(.5 -.7 .02) d(90 0 0 1)>
}
```
This defines a new frame `stick` with parent frame `table1`. This
frame has a shape, namely a sphere-swept box (`ST_ssBox`) of dimension
(.8, .025, .04) meters, radius 1cm (radius of the sphere-sweeping) and
color (.6,.3,.0).
See [geoms.h](https://github.com/MarcToussaint/rai/blob/master/rai/Geo/geoms.h) for the list of possible shape types `ST_...`
 It also has other attributes (`contact`, and
`logical`) that don't relate to the kinematic description itself.

The `stick` is positioned relative to `table1` as given by the transformation `Q`. The transformation is given as a chaining of little interpretable transformations, as in the old turtle language. Namely,
* `t(x y z)`  translation by (x,y,z)
* `q(q0 q1 q2 q3)`  rotation by a quaternion
* `r(r x y z)` rotation by `r` _radians_ around the axis (x,y,z)
* `d(d x y z)` rotation by `d` _degrees_ around the axis (x,y,z)
* `E(r p y)` rotation by roll-pitch-yaw Euler angles

Alternativly, `Q:<p1 p2 p3 q0 q1 q2 q3>` would directly specify a 7d transformation.

Any `joint:JT_...` attribute causes a joint to be associated to this frame.  See
[frame.h](https://github.com/MarcToussaint/rai/blob/master/rai/Kin/frame.h)
for the list of possible joint types `JT_...`. The joint's DOFs can be
initialized equivalently either with a `q` attribute (defining the
DOFs), or a `Q` attribute (defining the resulting relative
transformation generated by the joint).

<!-- SometimesHowever, often one wants the joint to be -->
<!-- located somewhere else, not directly in the frame's origin. E.g., the -->
<!-- frame `arm2` is centered with the second box that defines the arm. The -->
<!-- joint associated with that link is a bit lower in the chain. The `A` -->
<!-- and `B` tags allow you to split the transformation from `arm1` to -->
<!-- `arm2` into: `arm1`frame -> `A`transform -> `Q`transform of -->
<!-- joint-frame -> `B`transform -> `arm2`frame. Internally this -->
<!-- creates new intermediate frames, so that the data structure is -->
<!-- strictly a simple frame tree. -->

